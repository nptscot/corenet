---
format: gfm
---

# load leeds example data

```{r}
devtools::load_all()

library(sf)
library(ggplot2)
library(patchwork)
library(mapview)
library(dplyr)
library(igraph)

leeds_net = central_leeds_osm
edin_offroad_net = edinburgh_offroad |> filter(componentâ€ƒ == 7)
```

# load two remove dangles functions
removeDangles_1
- Accepts the parameters network (an sf object) and tolerance (default = 0.001).
- Directly casts the sf object to LINESTRING using sf::st_cast
- The tolerance parameter sets a distance threshold to determine whether an endpoint is "isolated" (dangle) based on spatial proximity to other points.

removeDangles_2
- Accepts the parameters network (an sf object) and percentile (default = 0.012).
- Converts the sf object into an igraph object using sf_to_igraph, enabling the calculation of vertex degrees. This step helps identify vertices with a degree of 1, which are potential dangles.
- The percentile determines the length threshold for classifying short dangling lines for removal.

Dangle Detection:
removeDangles_1:
- Uses spatial operations to detect dangles. It extracts the endpoints of each line segment and creates a spatial buffer around them using the tolerance value.
- By finding points that do not overlap with other buffered points, it identifies isolated (dangling) endpoints. This is more of a spatial proximity-based method.

removeDangles_2:
- Uses graph theory to identify dangles. It finds vertices (nodes) with degree 1 (dangles) in the graph representation of the network.
- It then extracts the first and last coordinates of each line and checks if any endpoints are dangle vertices. This approach focuses on graph-based dangle identification.

```{r}
removeDangles_1 = function(network, tolerance = 0.001) {
    geometry_types = sf::st_geometry_type(network)
    network_linestring = network[geometry_types == "LINESTRING", ]
    network_others = network[geometry_types != "LINESTRING", ]
    network_multilinestring = network[geometry_types == "MULTILINESTRING", ]
    network_multilinestring = sf::st_cast(network_multilinestring, "LINESTRING")

    # Combine with original LINESTRING geometries
    network_lines = rbind(network_linestring, network_multilinestring)
    # Extract and combine all end points of line segments
    end_points = do.call(rbind, lapply(network_lines$geometry, function(line) {
    endpoints = rbind(sf::st_coordinates(line)[1, ], sf::st_coordinates(line)[nrow(sf::st_coordinates(line)), ])
    sf::st_as_sf(data.frame(x = endpoints[, 1], y = endpoints[, 2]), coords = c("x", "y"), crs = sf::st_crs(network))
    }))

    # Identify unique end points (potential dangles) using a spatial join to find nearby points
    buffer_points = sf::st_buffer(end_points, dist = tolerance)
    overlaps = sf::st_intersects(buffer_points, buffer_points, sparse = FALSE)
    isolated_points = end_points[rowSums(overlaps) == 1,]

    # Filter out road segments that end in these isolated points
    segments_with_dangles = sapply(sf::st_geometry(network_lines), function(geom) {
    ends = sf::st_sfc(sf::st_point(sf::st_coordinates(geom)[1,]), sf::st_point(sf::st_coordinates(geom)[nrow(sf::st_coordinates(geom)),]), crs = sf::st_crs(network))
    any(sf::st_intersects(ends, isolated_points, sparse = FALSE))
    })

    network_without_dangles = network_lines[!segments_with_dangles, ]

    return(network_without_dangles)
}

removeDangles_2 = function(network, percentile = 0.012) {

    network$length = sf::st_length(network)
    network_g = sf_to_igraph(network)
    vertex_degrees = degree(network_g)

    dangle_vertices = which(vertex_degrees == 1)

    points = unique(do.call(rbind, lapply(st_geometry(network), function(line) {
    rbind(st_coordinates(line)[1, ], st_coordinates(line)[nrow(st_coordinates(line)), ])
    })))
    # Extract indices of LINESTRINGs to check
    line_indices = sapply(st_geometry(network), function(line) {
    coords = st_coordinates(line)
    c(which(points[,1] == coords[1,1] & points[,2] == coords[1,2]),
        which(points[,1] == coords[nrow(coords),1] & points[,2] == coords[nrow(coords),2]))
    })

    # sum of network$length
    sum_value = sum(network$length)
    
    # Median of network$length
    threshold_length = percentile* sum_value
    short_dangles = network[(line_indices[1,] %in% dangle_vertices | line_indices[2,] %in% dangle_vertices) & network$length < units::set_units(threshold_length, "meters"), ]

    network_clean = network[!((line_indices[1,] %in% dangle_vertices | line_indices[2,] %in% dangle_vertices) & network$length <  units::set_units(threshold_length, "meters")), ]
}

sf_to_igraph = function(network_sf) {
  # network_sf = cycle_net_components_1
  # Assuming network_sf is LINESTRING
  points = unique(do.call(rbind, lapply(network_sf$geometry, function(line) {
    rbind(st_coordinates(line)[1, ], st_coordinates(line)[nrow(st_coordinates(line)), ])
  })))
  points = unique(points)
  edges = do.call(rbind, lapply(network_sf$geometry, function(line) {
    start = which(points[,1] == st_coordinates(line)[1,1] & points[,2] == st_coordinates(line)[1,2])
    end = which(points[,1] == st_coordinates(line)[nrow(st_coordinates(line)),1] & points[,2] == st_coordinates(line)[nrow(st_coordinates(line)),2])
    c(start, end)
  }))
  graph = graph_from_edgelist(as.matrix(edges), directed = FALSE)
  return(graph)
}

```

# compare removeDangles_1 using leeds network with different tolerance values
```{r}
RD_leeds_1 = removeDangles_1(leeds_net, tolerance = 0.001)
RD_leeds_2 = removeDangles_1(leeds_net, tolerance = 10)

# Plot for network 1
p1 = ggplot() +
  geom_sf(data = leeds_net, color = "gray", size = 1) +
  geom_sf(data = RD_leeds_1, color = "blue", size = 1) +
  ggtitle("Network 1") +
  theme_minimal()

# Plot for network 2
p2 = ggplot() +
  geom_sf(data = leeds_net, color = "gray", size = 1) +
  geom_sf(data = RD_leeds_2, color = "red", size = 1) +
  ggtitle("Network 2") +
  theme_minimal()

# Combine both plots side by side using patchwork
combined_plot = p1 + p2 + plot_layout(ncol = 2)

# Display the plot
print(combined_plot)
```
# compare removeDangles_1 and removeDangles_2 using leeds network
# removeDangles_2 not applicable for leeds network
```{r}
# RD1_leeds = removeDangles_1(leeds_net, tolerance = 0.001)
# RD2_leeds = removeDangles_2(leeds_net, percentile = 0.012)

# # Plot for network 1
# p1 = ggplot() +
#   geom_sf(data = leeds_net, color = "gray", size = 2) +
#   geom_sf(data = RD1_leeds, color = "blue", size = 1) +
#   ggtitle("Network 1") +
#   theme_minimal()

# # Plot for network 2
# p2 = ggplot() +
#   geom_sf(data = leeds_net, color = "gray", size = 2) +
#   geom_sf(data = RD2_leeds, color = "red", size = 1) +
#   ggtitle("Network 2") +
#   theme_minimal()

# # Combine both plots side by side using patchwork
# combined_plot = p1 + p2 + plot_layout(ncol = 2)

# # Display the plot
# print(combined_plot)
```

# compare removeDangles_1 using edinburgh offroad network with different tolerance values

# result is pretty much same for different tolerance values
```{r}
RD_edin_1 = removeDangles_1(edin_offroad_net, tolerance = 0.012)
RD_edin_2 = removeDangles_1(edin_offroad_net, tolerance = 10)

# Plot for network 1
p1 = ggplot() +
  geom_sf(data = edin_offroad_net, color = "gray", size = 1) +
  geom_sf(data = RD_edin_1, color = "blue", size = 1) +
  ggtitle("Network using removeDangles_1_0.012") +
  theme_minimal()

# Plot for network 2
p2 = ggplot() +
  geom_sf(data = edin_offroad_net, color = "gray", size = 1) +
  geom_sf(data = RD_edin_2, color = "red", size = 1) +
  ggtitle("using removeDangles_1_10") +
  theme_minimal()

# Combine both plots side by side using patchwork
combined_plot = p1 + p2 + plot_layout(ncol = 2)

# Display the plot
print(combined_plot)

mapview(RD_edin_1,color = "blue") + mapview(RD_edin_2,color = "red") + mapview(edin_offroad_net, color = "black")
```

# compare removeDangles_1 and removeDangles_2 using edinburgh offroad network
removeDangles_2 is better
```{r}
RD1_edin = removeDangles_1(edin_offroad_net, tolerance = 0.001)
RD2_edin = removeDangles_2(edin_offroad_net, percentile = 0.012)

# Plot for network 1
p1 = ggplot() +
  geom_sf(data = edin_offroad_net, color = "gray", size = 2) +
  geom_sf(data = RD1_edin, color = "blue", size = 1) +
  ggtitle("Network using removeDangles_1") +
  theme_minimal()

# Plot for network 2
p2 = ggplot() +
  geom_sf(data = edin_offroad_net, color = "gray", size = 2) +
  geom_sf(data = RD2_edin, color = "red", size = 1) +
  ggtitle("Network using removeDangles_2") +
  theme_minimal()

# Combine both plots side by side using patchwork
combined_plot = p1 + p2 + plot_layout(ncol = 2)

# Display the plot
print(combined_plot)

mapview(RD1_edin,color = "blue") + mapview(RD2_edin,color = "red") + mapview(edin_offroad_net, color = "black")
```

# display the node degree of the network
```{r}
# Load necessary libraries
library(sf)
library(igraph)
library(dplyr)
library(ggplot2)
library(tidyr)  # Load tidyr for the separate function

# Extract edges (line segments)
edges = st_cast(leeds_net, "LINESTRING")

# Extract start and end coordinates of each line segment
edge_list = st_coordinates(edges) %>%
  as.data.frame() %>%
  group_by(L1) %>%
  summarize(
    x_start = first(X),
    y_start = first(Y),
    x_end = last(X),
    y_end = last(Y)
  )
# Create node identifiers by concatenating coordinates
edges_df = edge_list %>%
  mutate(
    from = paste(x_start, y_start, sep = ","),
    to = paste(x_end, y_end, sep = ",")
  ) %>%
  select(from, to)
# Create an undirected graph
g = graph_from_data_frame(edges_df, directed = FALSE)
# Calculate the degree of each node
node_degree = degree(g)

# Convert node_degree to a data frame
node_degree_df = data.frame(
  node = names(node_degree),
  degree = node_degree
)

# Split the node coordinates back into separate columns
node_degree_df = node_degree_df %>%
  separate(node, into = c("X", "Y"), sep = ",", convert = TRUE)

# Convert node_degree_df back to sf object
node_degree_sf = st_as_sf(node_degree_df, coords = c("X", "Y"), crs = st_crs(4326))

mapview(node_degree_sf, zcol = "degree") + mapview(leeds_net)
```


# new remove dangles function
```{r}
# Load necessary libraries
library(sf)
library(igraph)
library(dplyr)
library(tidyr)  

remove_dangles = function(network, crs_proj = 27700, tolerance = 1, iterative = TRUE) {
  
  # Step 1: Transform to Projected CRS
  projected_crs = st_crs(crs_proj)
  network_proj = st_transform(network, crs = projected_crs)
  
  # Step 2: Node the Network (Split Lines at Intersections)
  network_noded = st_union(network_proj)
  network_noded = st_line_merge(network_noded)
  network_noded_sf = st_cast(network_noded, "LINESTRING")
  
  # Step 3: Snap the Network to Itself 
  threshold = units::set_units(tolerance, "m")
  network_snapped = st_snap(network_noded_sf, st_union(network_noded_sf), tolerance = threshold)
  
  # Step 4: Extract Edges (Line Segments)
  edges = st_cast(network_snapped, "LINESTRING")
  
  # Step 5: Create Edge List with Start and End Coordinates
  edge_list = st_coordinates(edges) %>%
    as.data.frame() %>%
    group_by(L1) %>%
    summarize(
      x_start = first(X),
      y_start = first(Y),
      x_end = last(X),
      y_end = last(Y)
    )
  
  # Step 6: Create Node Identifiers
  edges_df = edge_list %>%
    mutate(
      from = paste(x_start, y_start, sep = ","),
      to = paste(x_end, y_end, sep = ",")
    ) %>%
    select(from, to)
  
  # Step 7: Create Graph
  g = graph_from_data_frame(edges_df, directed = FALSE)
  
  # Step 8: Remove Dangles (Iteratively or Once)
  if (iterative) {
    # Iterative Removal of Dangles
    repeat {
      # Calculate Node Degrees
      node_degree = degree(g)
      
      # Break the loop if no nodes with degree 1 are left
      if (all(node_degree > 1)) {
        break
      }
      
      # Identify Nodes with Degree 1
      node_degree_df = data.frame(
        node = names(node_degree),
        degree = node_degree
      ) %>%
        separate(node, into = c("X", "Y"), sep = ",", convert = TRUE)
      
      # Identify Dangle Nodes
      dangle_nodes = node_degree_df %>% filter(degree == 1)
      
      # Create Node Info for Joining
      node_info = node_degree_df
      
      # Merge Edge List with Node Degrees to Identify Edges Connected to Dangle Nodes
      edges_with_nodes = edge_list %>%
        mutate(
          from = paste(x_start, y_start, sep = ","),
          to = paste(x_end, y_end, sep = ",")
        ) %>%
        left_join(
          node_info %>%
            mutate(node = paste(X, Y, sep = ",")),
          by = c("from" = "node")
        ) %>%
        rename(degree_from = degree) %>%
        left_join(
          node_info %>%
            mutate(node = paste(X, Y, sep = ",")),
          by = c("to" = "node")
        ) %>%
        rename(degree_to = degree)
      
      # Identify Edges Connected to Dangle Nodes
      dangle_edges_indices = edges_with_nodes %>%
        filter(degree_from == 1 | degree_to == 1) %>%
        pull(L1)
      
      # Break if No Dangle Edges are Found
      if (length(dangle_edges_indices) == 0) {
        break
      }
      
      # Remove Dangle Edges
      edges = edges[-dangle_edges_indices, ]
      
      # Reconstruct Edge List and Graph for Next Iteration
      edge_list = st_coordinates(edges) %>%
        as.data.frame() %>%
        group_by(L1) %>%
        summarize(
          x_start = first(X),
          y_start = first(Y),
          x_end = last(X),
          y_end = last(Y)
        )
      
      edges_df = edge_list %>%
        mutate(
          from = paste(x_start, y_start, sep = ","),
          to = paste(x_end, y_end, sep = ",")
        ) %>%
        select(from, to)
      
      g = graph_from_data_frame(edges_df, directed = FALSE)
    }
  } else {
    # Single Removal of Dangles
    # Calculate Node Degrees
    node_degree = degree(g)
    
    # Identify Nodes with Degree 1
    node_degree_df = data.frame(
      node = names(node_degree),
      degree = node_degree
    ) %>%
      separate(node, into = c("X", "Y"), sep = ",", convert = TRUE)
    
    # Create Node Info for Joining
    node_info = node_degree_df
    
    # Merge Edge List with Node Degrees to Identify Edges Connected to Dangle Nodes
    edges_with_nodes = edge_list %>%
      mutate(
        from = paste(x_start, y_start, sep = ","),
        to = paste(x_end, y_end, sep = ",")
      ) %>%
      left_join(
        node_info %>%
          mutate(node = paste(X, Y, sep = ",")),
        by = c("from" = "node")
      ) %>%
      rename(degree_from = degree) %>%
      left_join(
        node_info %>%
          mutate(node = paste(X, Y, sep = ",")),
        by = c("to" = "node")
      ) %>%
      rename(degree_to = degree)
    
    # Identify Edges Connected to Dangle Nodes
    dangle_edges_indices = edges_with_nodes %>%
      filter(degree_from == 1 | degree_to == 1) %>%
      pull(L1)
    
    # Remove Dangle Edges
    edges = edges[-dangle_edges_indices, ]
  }
  
  # Step 9: Return the Cleaned Network
  # Transform Back to Original CRS
  cleaned_network = st_transform(edges, st_crs(network))
  
  return(cleaned_network)
}

```

# apply to leeds network and edinburgh offroad network

```{r}
cleaned_leeds = remove_dangles(leeds_net, crs_proj = 27700, tolerance = 1, iterative = FALSE)

cleaned_edin = remove_dangles(edin_offroad_net, crs_proj = 27700, tolerance = 1, iterative = FALSE)

ggplot() +
  geom_sf(data = leeds_net, color = "black", size = 2, alpha = 2) +
  geom_sf(data = cleaned_leeds, color = "red", size = 2) +
  ggtitle("Original Network (Black) vs Cleaned Network (Red)") +
  theme_minimal()

ggplot() +
  geom_sf(data = edin_offroad_net, color = "black", size = 2, alpha = 2) +
  geom_sf(data = cleaned_edin, color = "red", size = 2) +
  ggtitle("Original Network (Black) vs Cleaned Network (Red)") +
  theme_minimal()

mapview(leeds_net)
```